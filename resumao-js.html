

<p><strong>estilo camelCase =</strong> no qual a primeira palavra fica em caixa baixa (minúsculo) e a letra inicial das palavras seguintes ficam em caixa alta (maiúsculo).</p>

<p><strong>.toFixed(xx)</strong>Podemos controlar o número de casas decimais exibidas através da função. O x é o numero de casa decimal. </p>

<p><strong>.style </strong> modificar um estilo de um elemento selecionado com o Javascript, devemos primeiro acessar a propriedade style , que contêm todos os estilos daquele elemento. Depois que temos a propriedade .style em mãos, devemos especificar qual estilo desejamos alterar.</p>

<p><strong> .add() = </strong> adicionar uma classe é a função, recebe como parâmetro o nome da classe que queremos adicionar!Só devemos lembrar de chamar esta função depois de acessarmos a propriedade .classList. </p>


<p><strong>.classList</strong>contêm as classes do HTML selecionado.</p>

<p><strong> tag span= </strong> é um conteiner generico em linha para conteúdo fraseado , que não representa nada por natureza. Ele pode ser usado para agrupar elementos para fins de estilo (usando os atributos class ou id ), ou para compartilhar valores de atributos como lang. Ele deve ser usado somente quando nenhum outro elemento semântico for apropriado.É muito parecido com o elemento div , entretando  div é um elemento de nível de bloco enquanto span é um elemento em linha. </p>

<p><strong> event.preventDefault </strong> função do Javascript que previne o comportamento padrão de certos elementos. Como nem sempre event é usado (event.), às vezes, é desnecessário passá-lo para a função. Mas neste caso, é ele quem contém a função .preventDefault(), na qual estamos interessados, logo, precisaremos passá-lo como parâmetro.As boas práticas do mercado, devemos sempre usar event como parâmetro e as funções que são chamadas pelos eventos. </p>

<p><strong>funções nomeadas</strong>como o próprio nome diz, são as funções que levam um nome em sua criação e que podem ser invocadas posteriormente (Ex. function xxxx() ). </p>

<p><strong>funções anônimas</strong>funções que não tem nome e só são chamadas no contexto aonde foram declaradas. Elas são muito usadas em conjunto com a função addEventListener(), onde normalmente a ação que desejamos chamar só deve ser chamada naquele local (Ex. function() ).</p>

<p><strong>createElement() </strong> responsável por criar elementos no Javascript. Com ela passamos o nome da tag que queremos criar e ela nos retorna um objeto HTML que pode ser alterado com as propriedades do Javascript, como a .textContent e a .classList. </p>

<h3>Sabemos que quebrar uma grande função complexa é uma boa prática por causa de diversos fatores, mas podemos citar como os principais deles: </h3>

<li>Dar manutenção ao código fica muito mais fácil, visto que agora podemos examinar vários pequenos blocos , que são muito mais fáceis de compreender do que um grande bloco de texto.</li>
<li>quebrar uma grande função, também estamos deixando ela com menos responsabilidades, com a meta de atingir o ideal de que cada função tenha apenas uma única responsabilidade.</li>
<li>O código também fica muito mais fácil de testar, pois se temos diversas funções pequenas conseguimos ir testando uma a uma em busca de erros ou bugs do código.</li>
<li>E por último, a legibilidade do código aumenta muito, pois dando nomes semânticos a cada uma das funções menores conseguimos deixar bem claro o que aquela parte do código deve fazer e facilita o entendimento do todo como um geral.</li>

<p><strong>forEach() </strong> uma forma de iterar sobre os elementos de um array, passamos para ela uma função por parâmetro, e nessa função fazemos o que quisermos para cada item do array. </p>

<p><strong>innerHTML</strong>podemos obter o conteúdo HTML (HTML interno) de um elemento, quando utilizada para obter o HTML interno de um elemento, o retorno da propriedade innerHTML será todo o conteúdo HTML, seja tags, atributos, classes, etc, no formato de uma String, conseguimos editar o HTML interno de um elemento.

<p><strong>dblclick =</strong> duplo click</p>

<p><strong>this =</strong> é a palavra reservada, ele busca o elemento atrelado ao evento, o que está causando o evento, this está atrelado ao dono do evento.

<p><strong>bubbling. =</strong> delegação, processo possível pelo borbulhamento:</p>
<li><strong>parentNode =</strong> pai do elemento</li>
<li><strong>event.target =</strong>alvo, o elemento em si</li>

<p><strong>setTimeout =</strong> segura a função , pra esperar e ai exutar o comando abaixo, sempre em milesegundos. Ex. 500 milegundos = 1/2 segundo</p>

<p><strong>addEventListener() =</strong> recebe dois parâmetros, o nome do evento a ser escutado e uma função com a ação que deve executar.</p>

<p><strong>new RegExp(xxxx,"i"); =</strong> expressão regula = passa 2 parametros, primeiro parâmetro que devemos passar para o construtor é o padrão (o texto da expressão regular, o que deve ser buscado) e o segundo parâmetro são uma ou mais flags (representando como queremos que a expressão regular busque).Por exemplo, podemos definir que não queremos que haja distinção entre letras maiúsculas e minúsculas, através da flag i. No caso "i", significa string, onde ele ignora se é maiuscula ou minuscula, ele procura por todos. </p>

<p><strong>.test() =</strong> passa pra ela o que quer testa, retornando verdadeiro ou falso.</p>

<p><strong>new XMLHttpRequest(); =</strong> envia requisição, o objeto XMLHttpRequest é quem é responsável por fazer requisições HTTP assíncronas com Javascript. Apesar de ter o XML no nome hoje em dia este objeto pode trafegar diversos outros tipos de dados além do XML, este nome só se manteve devido a um legado histórico. </p>
<p>E para instanciar um novo Objeto XMLHttpRequest devemos utilizar a sintaxe com a palavrinha new</p>

<li><strong>xhr.open("get", "xxxxxx"); =</strong> abrindo o conteudo da requisição, precisamos configurar nossa requisição para dizer para qual servidor queremos enviá-la e também qual método HTTP devemos usar.Fazemos isto através do método .open() , e o primeiro item é o tipo que queremos. </li>
<li><strong>xhr.addEventListener("load", function(){}); =</strong> um escutador pra verificar quando carregou e executar a função. </li>
<li><strong>xhr.responseText =</strong> ele traz as informações que foram ouvidas pelo escutador. </li>
<li><strong>xhr.send(); =</strong> a requisição só é enviada mesmo após chamarmos o send. </li>

<p><strong>typeof</strong> retorna uma string indicando o tipo de um operando.</p>

<p><strong> .appendChild(xx) </strong> adiciona o item a lista, método anexa um nó (elemento) como o último filho de um elemento.</p>

<p><strong>.forEach(xx) </strong>uma forma mais elegante para trabalhar com o for, permite executar uma função para cada item de um array. (array.forEach(funcao([valorAtual, índice, array]), argumentoThis)) </p>

<p><strong>

<p><strong>

<p><strong>

<p><strong>

<p><strong>

<p><strong>
    

